// 문제3) 초반 10회는 상승, 10회 이후는 상승 or 하강 랜덤
//       상승에서 하강 혹은 하강에서 상승으로 변경 시 10회 이상 해당 방향으로 값 변환 유지


#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
    int N, delta; // N: 개수, delta: 속도변화
    int *vel; // int 배열 선언
    int up_cnt=0; // 속도 상승 카운트
    int down_cnt=0; // 속도 하강 카운트


    printf("속도 데이터의 수: ");
    scanf("%d", &N); // 데이터 개수 입력
    vel = (int*)malloc(sizeof(int)*N); // 데이터 개수만큼 배열 생성

    // 배열 생성 부분은 int vel[숫자]; 로 선언 가능

    srand(time(NULL)); // random 함수 초기화

    for(int i=0; i<=N; i++){ // 0~N까지 반복
        if(i == 0) { // i=0 즉, 첫번째 일 때
            vel[i]=rand()%21; // 랜덤 값 부여
            up_cnt+=1; // 상승 카운트 1 증가, 상승 1회
        }

        else if(i<10) { // i<10 이하 일 때 즉, 10회 미만 반복일 때
            vel[i]=rand()%21+vel[i-1]; // 현재 값에 이전 값의 +20 이내에 랜덤한 값 부여
            // rand()%(B - A + 1) + A -> 최대값=B, 최솟값=A
            up_cnt+=1; // 상승 카운트 1 증가, 상승 1회
        }

        else{
            if(up_cnt>=10) { // 상승 카운트가 10 이상일 때. 즉, 상승 10회 이상 했을 때
                vel[i]=rand()%(41)+vel[i-1]-20; // 현재 값에 이전 값의 -20 ~ +20 범위 내의 랜덤한 값 부여
                if(vel[i]>vel[i-1]) { // 현재 값이 이전 값 보다 크다면
                    up_cnt+=1; // 상승 카운트 1 증가, 상승을 얼만큼 했는 지 표시하기 위한 값
                    down_cnt=0; // 하강 카운트 0으로 초기화. 하강하지 않는 상태라는 것을 명시
                }
                else if(vel[i]<vel[i-1]) { // 현재 값이 이전 값 보다 작다면. 현재 부분에서는 값의 상승-하강이 변화
                    printf("------%d번 상승이후 감소------\n", up_cnt); // 값 변화 부분 구분을 위한 출력
                    up_cnt=0; // 상승 카운트 0으로 초기화, 상승하지 않는 상태라는 것을 명시
                    down_cnt+=1; // 하강 카운트 1 증가, 하강을 얼만큼 했는 지 표시하기 위한 값
                }
            }
            else if(down_cnt>=10) { // 하강 카운트가 10 이상일 경우. 즉, 10회 이상 하강했을 경우
                vel[i]=rand()%(41)+vel[i-1]-20; // 현재 값에 이전 값의 -20 ~ +20 범위 내의 랜덤한 값 부여
                if(vel[i]>vel[i-1]) { // 현재 값이 이전 값보다 클 경우. 현재 부분에서는 값의 하강-상승 변화
                    printf("------%d번 감소 이후 상승------\n", down_cnt); // 값 변화 부분 구분을 위한 출력
                    up_cnt+=1; // 상승 카운트 1 증가
                    down_cnt=0; // 하강 카운트 0으로 초기화
                }
                else if(vel[i]<vel[i-1]) { // 현재 값이 이전 값보다 작다면, 현재 상태에서는 하강 상태 유지
                    down_cnt+=1; // 하강 카운트 1 증가
                    up_cnt=0; // 상승 카운트 0으로 초기화
                }
            }
            else if(up_cnt>=1 && up_cnt<10){ // 상승이 1~9회 사이일 경우
                vel[i]=rand()%21+vel[i-1]; // 현재 값에 이전 값의 +20 이내 랜덤한 값 부여
                up_cnt++; // 상승 카운트 1 증가
            }
            else if(down_cnt>=1 && down_cnt<10){ // 하강이 1~9회 사이일 경우
                vel[i]=rand()%21+vel[i-1]-20; // 현재 값에 이전 값의 -20 이내 랜덤한 값 부여
                down_cnt++; // 하강 카운트 1 증가
            }
        }        
    
        printf("%d: %d (%d, %d)\n", i, vel[i], up_cnt, down_cnt); // 횟수: 값 (상승 횟수, 하강 횟수) 출력
    }

    free(vel); // malloc로 부여한 메모리 반환 int vel[숫자]; 로 정수 배열을 선언한 경우 필요 x

    return 0;
}